#  dict 查找性能远大于list
#  随着数据的增大list查找时间也会增大而dict不会
#  dict内存消耗大
"""
当你初始化一个字典以后，Python单独生成了一个长度为8的一维数组。然后又生成了一个空的二维数组。
indices = [None, 0, None, None, None, None, None, None]

entries = [[-5954193068542476671, 指向name的指针, 执行kingname的指针]]
存储数据：

对新存入的键进行hash 取值后对8取余数(比如余5)，那么就把它放在刚刚初始化的二维数组中，下标为5的这一行
这个二维数组下标为5的这一行，第一个值为name的hash值，第二个值为name这个字符串所在的内存的地址（指针就是内存地址），第三个值为kingname这个字符串所在的内存的地址。
[
    [hash(key0)的值, 指向key0的指针, 指向value0的指针]
    [hash(key1)的值, 指向key1的指针, 指向value1的指针]
    [hash(key2)的值, 指向key2的指针, 指向value2的指针]
    [hash(key3)的值, 指向key3的指针, 指向value3的指针]
    [hash(key4)的值, 指向key4的指针, 指向value4的指针]
]

读取数据：
先计算在当前运行时下面，求key对应的Hash值，再对8取余数(比如余1)，那么二维数组里面，下标为1的这一行就是需要的键值对。直接返回这一行第三个指针对应的内存中的值
我们把indices这个一维数组里面，下标为1的位置修改为0。再去读entries里面，下标为0的这一行的数据，也就是key对应的数据了。

当你要循环遍历字典的Key的时候，Python底层会遍历这个二维数组，如果当前行有数据，那么就返回Key指针对应的内存里面的值。如果当前行没有数据，那么就跳过。所以总是会遍历整个二位数组的每一行。

"""
# https://zhuanlan.zhihu.com/p/73426505
